/*! PapaParse v5.4.1 - https://github.com/mholt/PapaParse */
(function(root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = factory();
    } else {
        root.Papa = factory();
    }
}(typeof self !== 'undefined' ? self : this, function() {
    'use strict';
    var IS_WORKER = typeof window === 'undefined';
    var global = IS_WORKER ? self : window;
    var IS_PAPA_WORKER = IS_WORKER && typeof importScripts !== 'undefined';
    var workers = {};
    var Papa = {};
    Papa.parse = function(input, config) {
        config = config || {};
        var streamer = new ChunkStreamer(config);
        streamer.parse(input);
        return streamer;
    };
    Papa.unparse = function(data, config) {
        if (typeof data === 'string') {
            return data;
        }
        config = config || {};
        if (!data || typeof data !== 'object') {
            return '';
        }
        var BOM = '\ufeff';
        var hasHeader = config.columns !== undefined;
        var header = hasHeader ? config.columns : data[0] ? Object.keys(data[0]) : [];
        var csv = config.bom !== false && config.bom !== 0 ? BOM : '';
        if (header.length) {
            csv += header.map(function(field) {
                return escapeCSVValue(field, config);
            }).join(config.delimiter || ',');
            csv += config.newline || '\n';
        }
        for (var i = 0; i < data.length; i++) {
            var row = data[i];
            if (header.length) {
                csv += header.map(function(field) {
                    return escapeCSVValue(row[field] !== undefined ? row[field] : '', config);
                }).join(config.delimiter || ',');
            } else {
                csv += Object.keys(row).map(function(key) {
                    return escapeCSVValue(row[key], config);
                }).join(config.delimiter || ',');
            }
            if (i < data.length - 1) {
                csv += config.newline || '\n';
            }
        }
        return csv;
    };
    function escapeCSVValue(value, config) {
        if (value === null || value === undefined) {
            return '';
        }
        var string = String(value);
        var quoteChar = config.quoteChar || '"';
        var escapeChar = config.escapeChar || '"';
        var delimiter = config.delimiter || ',';
        if (string.indexOf(quoteChar) !== -1 || string.indexOf(delimiter) !== -1 || string.indexOf('\n') !== -1 || string.indexOf('\r') !== -1) {
            return quoteChar + string.replace(new RegExp(escapeChar, 'g'), escapeChar + escapeChar) + quoteChar;
        }
        return string;
    }
    function ChunkStreamer(config) {
        this._handle = null;
        this._finished = false;
        this._input = null;
        this._baseIndex = 0;
        this._rowCount = 0;
        this._start = 0;
        this._nextChunk = null;
        this._completeResults = {
            data: [],
            errors: [],
            meta: {}
        };
        this._paused = false;
        this._aborted = false;
        this._delimiter = '';
        this._config = config;
        this._step = config.step;
        this._chunkSize = config.chunkSize;
        this._complete = config.complete;
        this._header = false;
        this._dynamicTyping = config.dynamicTyping || false;
        this._transform = config.transform;
    }
    ChunkStreamer.prototype.parse = function(input) {
        this._input = input;
        if (typeof input === 'string') {
            this._nextChunk = input;
            this._finished = true;
            this._parseChunk();
        } else if (input && typeof input.read === 'function') {
            this._nextChunk = '';
            var streamer = this;
            input.on('data', function(chunk) {
                streamer._nextChunk += chunk;
                streamer._parseChunk();
            });
            input.on('end', function() {
                streamer._finished = true;
                streamer._parseChunk();
            });
        } else {
            this._nextChunk = String(input || '');
            this._finished = true;
            this._parseChunk();
        }
    };
    ChunkStreamer.prototype._parseChunk = function() {
        if (this._paused || this._aborted) {
            return;
        }
        if (!this._nextChunk) {
            return;
        }
        var chunk = this._nextChunk;
        this._nextChunk = null;
        var rows = this._parse(chunk);
        if (this._step) {
            for (var i = 0; i < rows.length; i++) {
                this._step({ data: rows[i], errors: [], meta: {} });
            }
        } else {
            this._completeResults.data = this._completeResults.data.concat(rows);
        }
        if (this._finished && this._complete) {
            this._complete(this._completeResults);
        }
    };
    ChunkStreamer.prototype._parse = function(input) {
        var delimiter = this._config.delimiter;
        if (!delimiter) {
            var delimGuess = guessDelimiter(input);
            delimiter = delimGuess || ',';
        }
        this._delimiter = delimiter;
        var quoteChar = this._config.quoteChar || '"';
        var escapeChar = this._config.escapeChar || '"';
        var skipEmptyLines = this._config.skipEmptyLines || false;
        var comments = this._config.comments || false;
        var rows = [];
        var currentRow = [];
        var currentField = '';
        var insideQuotes = false;
        var i = 0;
        var len = input.length;
        while (i < len) {
            var char = input[i];
            if (char === quoteChar && (!insideQuotes || input[i + 1] === quoteChar)) {
                if (insideQuotes && input[i + 1] === quoteChar) {
                    currentField += quoteChar;
                    i += 2;
                    continue;
                }
                insideQuotes = !insideQuotes;
                i++;
                continue;
            }
            if (char === delimiter && !insideQuotes) {
                currentRow.push(currentField.trim());
                currentField = '';
                i++;
                continue;
            }
            if ((char === '\n' || char === '\r') && !insideQuotes) {
                if (currentField || currentRow.length) {
                    currentRow.push(currentField.trim());
                    currentField = '';
                }
                if (currentRow.length && (!skipEmptyLines || currentRow.some(function(field) { return field.length > 0; }))) {
                    if (!comments || !currentRow[0] || currentRow[0].indexOf(comments) !== 0) {
                        rows.push(currentRow);
                    }
                }
                currentRow = [];
                if (char === '\r' && input[i + 1] === '\n') {
                    i++;
                }
                i++;
                continue;
            }
            currentField += char;
            i++;
        }
        if (currentField || currentRow.length) {
            currentRow.push(currentField.trim());
        }
        if (currentRow.length && (!skipEmptyLines || currentRow.some(function(field) { return field.length > 0; }))) {
            rows.push(currentRow);
        }
        if (this._header && rows.length > 0) {
            var headers = rows[0];
            var dataRows = rows.slice(1);
            var result = [];
            for (var j = 0; j < dataRows.length; j++) {
                var rowObj = {};
                for (var k = 0; k < headers.length; k++) {
                    rowObj[headers[k]] = dataRows[j][k] || '';
                }
                result.push(rowObj);
            }
            return result;
        }
        return rows;
    };
    function guessDelimiter(input) {
        var delimiters = [',', ';', '\t', '|'];
        var maxCount = 0;
        var guessedDelimiter = ',';
        for (var i = 0; i < delimiters.length; i++) {
            var count = (input.match(new RegExp('\\' + delimiters[i], 'g')) || []).length;
            if (count > maxCount) {
                maxCount = count;
                guessedDelimiter = delimiters[i];
            }
        }
        return guessedDelimiter;
    }
    Papa.workers = workers;
    return Papa;
}));

